# Use StaticParallelGraph.ipynb
from langgraph.graph import StateGraph, START, END
from typing import List, Annotated, TypedDict

import random, time

def appendList(current: List[int], new: List[int] ) -> List[int]:
    return current+new

class StaticParallelGraph(TypedDict):
    total : int
    numbers : Annotated[List[int], appendList]


# Define Worker Node
def worker_node(state: StaticParallelGraph) -> StaticParallelGraph:
    print(f"Worker Start Time -> {time.time()}")
    rint = random.randint(1,10)         # Genarate random num bet 1 to 10
    time.sleep(rint)                    # Add processing delay
    print(f"{rint} generated by Worker Node")
    print(f"Worker End Time -> {time.time()}")
    return {"numbers": [rint]}

# Define Aggregator Node
def aggregator_node(state: StaticParallelGraph) -> StaticParallelGraph:
    nums = state["numbers"]         # Extract the total numbers generated and return num
    return {"total" : sum(nums)}

graph = StateGraph(StaticParallelGraph)

# Add Nodes
graph.add_node("Worker-A", worker_node)
graph.add_node("Worker-B", worker_node)
graph.add_node("Worker-C", worker_node)
graph.add_node("Aggregator", aggregator_node)

# Define Edges
graph.add_edge(START, "Worker-A")
graph.add_edge(START, "Worker-B")
graph.add_edge(START, "Worker-C")

graph.add_edge("Worker-A", "Aggregator")
graph.add_edge("Worker-B", "Aggregator")
graph.add_edge("Worker-C", "Aggregator")

graph.add_edge("Aggregator", END)

graph_compiled = graph.compile()

graph_start_time = time.time()
response=graph_compiled.invoke({"total": 0, "numbers": []})
graph_end_time = time.time()

print(response)
print(f"Parallel execution took : {int(graph_end_time - graph_start_time)} secs")
print(f"Sequential execution would have taken : {response['total']} secs")
print(f"Speed up by a factor of : {round(response['total'] / int(graph_end_time - graph_start_time))}")
